% -*- mode: noweb; noweb-default-code-mode: R-mode; -*-
\documentclass[article]{tragula}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{wrapfig}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% just as usual
\author{Robin K. S. Hankin\orcid{https://orcid.org/0000-0001-5982-0415}\\ University of Stirling}
\title{Quadratic forms in \proglang{R}: introducing the \pkg{quadform} package}

\Shorttitle{The \pkg{weyl} package}

%\VignetteIndexEntry{A vignette for the weyl package}
%% for pretty printing and a nice hypersummary also set:
%% \Plainauthor{Achim Zeileis, Second Author} %% comma-separated

\Plaintitle{Quadratic forms in {R}: introducing the {weyl} package}
\Shorttitle{The \pkg{weyl} package}

%% an abstract and keywords
\Abstract{
The \pkg{quadform} package evaluates a range of quadratic forms, using
efficient methods.  Unnecessary transposes are not performed.  Complex
values are handled consistently.
}

\Keywords{Quadratic forms}

%% publication information
%% NOTE: This needs to filled out ONLY IF THE PAPER WAS ACCEPTED.
%% If it was not (yet) accepted, leave them commented.
\Volume{0}
\Issue{0}
%% \Month{September}
\Year{0000}
\Submitdate{0000-00-00}
\Acceptdate{0000-00-00}
\Repository{https://github.com/RobinHankin/quadform} %% this line for Tragula

\Address{
Robin K. S. Hankin\\
University of Stirling\\
Scotland\\
email: \email{hankin.robin@gmail.com}
}

%% need no \usepackage{Sweave.sty}


\begin{document}

\textbf{This document has not been peer-reviewed and is not an
  accepted \textsf{Tragula} publication.  It is intended as an example
  of the style and substance appropriate for submission to
  \textsf{Tragula}.}

\section{Overview}

\setlength{\intextsep}{0pt}
\begin{wrapfigure}{r}{0.2\textwidth}
\begin{center}
\includegraphics[width=1in]{\Sexpr{system.file("help/figures/quadform.png",package="quadform")}}
\end{center}
\end{wrapfigure}

Quadratic forms are polynomials with all terms of degree 2.  Given a
column vector ${\mathbf x}=(x_1,\ldots,x_n)^\top$ and an $n\times n$
matrix $M$ then the function
$f\colon\mathbb{R}^n\longrightarrow\mathbb{R}$ given by $f({\mathbf
  x})=x^TMx$ is a quadratic form~\citep{gentle2024}; we extend to
complex vectors by mapping ${\mathbf z}=(z_1,\ldots, z_n)^\top$ to
${\mathbf z}^*M{\mathbf z}$, where $z^*$ means the complex conjugate
of $z^T$.  These are implemented in the package with
\code{quad.form(M,x)} which is essentially

<<showquad.form, eval=FALSE>>=
function(M,x){crossprod(crossprod(M, Conj(x)), x)}
@ 

Using \code{quad.form()} is preferable to \code{t(x) \%*\% M \%*\% x}
on several grounds.  Firstly, it streamlines and simplifies code;
secondly, it is more efficient; and thirdly it handles the complex
case consistently: \code{crossprod(M,x)} evaluates \code{t(x) \%*\% M}
and not \code{t(Conj(x)) \%*\% M}, as one would usually want.  The
package includes similar functionality for other related expressions
such as $\mathbf{x}^* M\mathbf{y}$ and $\mathbf{x}^*
M^{-1}\mathbf{x}$.  The package also has functionality for evaluating
quadratic forms of matrices.  Given $M_{[n\times n]}$ and
$\mathbf{x}_{[n\times k]}$, then $F=\mathbf{x}^*M\mathbf{x}$ is
$[k\times k]$, and sometimes one needs $\operatorname{diag}(F)$ or
$\operatorname{trace}(F)$.  These are implemented as
\code{quad.diag()} and \code{quad.trace()} respectively.  A list is
provided in table~\ref{quadforms}.

\begin{table}
  \centering
  \begin{tabular}{lcll}
package idiom & definition & base \proglang{R} idiom & terse form\\ \hline
  \code{ht(x)} & $\mathbf{x}^{*}=\overline{\mathbf{x}^{\scriptscriptstyle T}}^{\rule{0mm}{5mm}}$ &
  \code{Conj(t(x))} & \code{ht(x)}\\
  \code{cprod(x,y)} & ${\mathbf{x}^{*}\mathbf{y}}$ & \code{ht(x) \%*\% y} & \code{cp()}\\
  \code{tcprod(x,y)} &  $\mathbf{x}\mathbf{y}^{*}$
   & \code{x \%*\% ht(y)} & \code{tcp()}\\
  \code{quad.form(M,x)} &  $\mathbf{x}^{*}M\mathbf{x}$
   & \code{ht(x) \%*\% M \%*\% x} & \code{qf()}\\
  \code{quad.form.inv(M,x)} &  $\mathbf{x}^{*}M^{-1}\mathbf{x}$
   & \code{ht(x) \%*\% solve(M) \%*\% x} & \code{qfi()}\\
  \code{quad.tform(M,x)} &  $\mathbf{x}M\mathbf{x}^{*}$
   & \code{x \%*\% A \%*\% ht(x)} & \code{qt()}\\
  \code{quad.tform.inv(M,x)} &  $\mathbf{x}M^{-1}\mathbf{x}^{*}$
   & \code{x \%*\% solve(M) \%*\% ht(x)} & \code{qti()}\\
  \code{quad3.form(M,l,r)} &  $\mathbf{l}^{*}M\mathbf{r}$
   & \code{t(l) \%*\% M \%*\% r} & \code{q3()}\\
  \code{quad3.form.inv(M,l,r)} &  $\mathbf{l}^{*}M^{-1}\mathbf{r}$
   & \code{t(l) \%*\% solve(M) \%*\% r} & \code{q3i()}\\
  \code{quad3.tform(M,l,r)} &  $\mathbf{l}M\mathbf{r}^{*}$
   & \code{l \%*\% M \%*\% t(r)} & \code{q3t()}\\
  \code{quad.diag(M,x)} &  $\operatorname{diag}(\mathbf{x}^{*}M\mathbf{x})$
   & \code{diag(quad.form(M,x))} & \code{qd()}\\
  \code{quad.tdiag(M,x)} &  $\operatorname{diag}(\mathbf{x}M\mathbf{x}^{*})$
   & \code{diag(quad.tform(M,x))} & \code{qtd()}\\
  \code{quad3.diag(M,l,r)} &  $\operatorname{diag}(\mathbf{l}^{*}M\mathbf{r})$
   & \code{diag(quad3.form(M,l,r))} & \code{q3d()}\\
  \code{quad3.tdiag(M,l,r)} &  $\operatorname{diag}(\mathbf{l}M\mathbf{r}^{*})$
   & \code{diag(quad3.tform(M,l,r))} & \code{q3td()}\\
  \code{quad.trace(M,x)} &  $\operatorname{tr}(\mathbf{x}^{*}M\mathbf{x})$
   & \code{tr(quad.form(M,x))} & \code{qt()}\\
  \code{quad.ttrace(M,x)} &  $\operatorname{tr}(\mathbf{x}M\mathbf{x}^{*})$
   & \code{tr(quad.tform(M,x))} & \code{qtt()}
  \end{tabular}
  \caption{Quadratic\label{quadforms} forms.  Here, $\mathbf{x}^{*}$ denotes the
    \emph{complex conjugate} of the transpose, also known as the Hermitian
    transpose}
  \end{table}

The main motivation for the package is nicer code.  For example, the
\pkg{emulator} package~\citep{hankin2005} has to manipulate the
following expression:

\[
\left[H_x-H^\top A^{-1}U\right]^\top
\left[H^\top\left(H^\top A^{-1}H\right)^{-1}H\right]
\left[H_x-H^\top A^{-1}U\right].
\]

Direct R idiom would be:

<<directRidiom, eval=FALSE>>=
t(Hx - t(H) %*% solve(A) %*% U) %*%
t(H) %*% solve(t(H) %*% solve(A) %*% H) %*% H %*%
(Hx - t(H) %*% solve(A) %*% U)
@

But \pkg{quadform} idiom is:

<<quadidiom, eval=FALSE>>=
quad.form(quad.form.inv(quad.form.inv(A,H),H), Hx - quad3.form.inv(A,H,U))
@

and in terse form becomes:

<<terseform, eval=FALSE>>=
qf(qfi(qfi(A,H),H), Hx - q3fi(A,H,U))
@

which is certainly shorter, arguably more elegant, and possibly
faster; it also operates correctly in the complex case, as needed for
working with the complex multivariate Gaussian
distribution~\citep{hankin2015}.

\bibliography{quadform}
\end{document}
